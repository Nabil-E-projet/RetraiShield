import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from data_generator import generate_demo_data
from rgpd_analyzer import classify_columns, calculate_k_anonymity, calculate_risk_score, get_risk_label
from anonymizer import anonymize_data, create_metadata_header
from sql_generator import generate_sql_anonymization_script
from datetime import datetime

st.set_page_config(
    page_title="RetraiShield - RGPD Platform",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- CSS PERSONNALIS√â POUR UN LOOK PREMIUM ---
st.markdown("""
<style>
    .main-header {font-size: 2.5rem; color: #1E3A8A; font-weight: 700;}
    .sub-header {font-size: 1.5rem; color: #1E3A8A; margin-top: 20px;}
    .card {padding: 20px; border-radius: 10px; background-color: #f8f9fa; border: 1px solid #e9ecef; margin-bottom: 20px;}
    .stMetric {background-color: #ffffff; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; box-shadow: 0 2px 4px rgba(0,0,0,0.05);}
</style>
""", unsafe_allow_html=True)

# initialisation de la session
if 'df' not in st.session_state:
    
    L'algorithme scanne les noms de colonnes et le contenu pour d√©tecter les risques RGPD.
    """)
    
    if df_display is None:
        st.info("üëà Veuillez charger ou g√©n√©rer des donn√©es depuis le menu lat√©ral.")
    else:
        # KPIs en haut de page
        with st.spinner("Analyse du dataset..."):
            classification = classify_columns(df_display)
        
        col1, col2, col3, col4 = st.columns(4)
        col1.metric("Identifiants Directs", len(classification['identifiants_directs']), 
                   help="Donn√©es identifiant directement une personne (Nom, Pr√©nom, ID Assur√©...). √Ä masquer imp√©rativement.",
                   delta_color="inverse")
        col2.metric("Quasi-Identifiants", len(classification['quasi_identifiants']), 
                   help="Donn√©es qui, combin√©es, peuvent permettre une r√©-identification (Date naissance, Code postal, Sexe...). √Ä g√©n√©raliser.",
                   delta_color="off")
        col3.metric("Donn√©es Sensibles", len(classification['donnees_sensibles']), 
                   help="Informations confidentielles (Revenus, Pension, Sant√©...).",
                   delta_color="off")
        col4.metric("Total Colonnes", len(df_display.columns))
        
        st.markdown("---")
        
        # Contenu principal
        col_left, col_right = st.columns([2, 1])
        
        with col_left:
            st.markdown('<p class="sub-header">Aper√ßu des donn√©es</p>', unsafe_allow_html=True)
            st.dataframe(df_display.head(10), use_container_width=True)
        
        with col_right:
            st.markdown('<p class="sub-header">Classification</p>', unsafe_allow_html=True)
            
            # Cr√©ation d'un tableau plus visuel pour la classification
            class_data = []
            for col in df_display.columns:
                if col in classification['identifiants_directs']:
                    tag = "üî¥ ID Direct"
                elif col in classification['quasi_identifiants']:
                    tag = "üü† Quasi-ID"
                elif col in classification['donnees_sensibles']:
                    tag = "üü° Sensible"
                else:
                    tag = "üü¢ Autre"
                class_data.append({"Colonne": col, "Type": tag})
            
            st.dataframe(pd.DataFrame(class_data), use_container_width=True, hide_index=True)

# --- PAGE 2: ANALYSE RISQUE ---
elif page == "2. Analyse des Risques":
    st.markdown('<p class="main-header">üìä Analyse des Risques (k-anonymat)</p>', unsafe_allow_html=True)
    
    with st.expander("‚ÑπÔ∏è Comprendre le k-anonymat", expanded=False):
        st.markdown("""
        **Qu'est-ce que le k-anonymat ?**
        
        C'est une mesure de protection de la vie priv√©e. Un jeu de donn√©es est **k-anonyme** si chaque individu est "cach√©" dans un groupe d'au moins **k** personnes partageant les m√™mes caract√©ristiques (quasi-identifiants).
        
        *Exemple : Si k=5, cela signifie que pour toute combinaison de (Date Naissance + Code Postal + Sexe), il y a au moins 5 personnes identiques. Impossible de savoir qui est qui parmi ces 5.*
        
        **Seuils recommand√©s :**
        - **k < 5** : üî¥ Risque √©lev√© de r√©-identification
        - **k ‚â• 5** : üü¢ Protection standard accept√©e
        """)
    
    if df_display is None:
        st.info("üëà Veuillez charger des donn√©es.")
    else:
        # S√âLECTEUR DE DATASET (Nouveau workflow it√©ratif)
        dataset_options = ["Donn√©es Originales"]
        if st.session_state.df_anon is not None:
            dataset_options.append("Donn√©es Anonymis√©es üîí")
        
        selected_dataset = st.radio("Jeu de donn√©es √† analyser :", dataset_options, horizontal=True)
        
        if "Originales" in selected_dataset:
            df_analysis = df_display
            st.caption("Analyse des donn√©es brutes (avant traitement)")
        else:
            df_analysis = st.session_state.df_anon
            st.success("Analyse des donn√©es prot√©g√©es (apr√®s anonymisation)")

        classification = classify_columns(df_analysis)
        available_qi = classification['quasi_identifiants']
        
        # Configuration de l'analyse
        with st.expander("‚öôÔ∏è Configuration de l'analyse", expanded=True):
            default_qi = [c for c in ['date_naissance', 'code_postal', 'sexe', 'tranche_age', 'departement'] if c in available_qi]
            if not default_qi and available_qi: default_qi = available_qi[:3]
            
            selected_qi = st.multiselect(
                "Quasi-identifiants pour le calcul:",
                options=available_qi,
                default=default_qi
            )
        
        if selected_qi:
            with st.spinner("Calcul des risques en cours..."):
                # Pr√©paration calcul
                df_calc = df_analysis.copy()
                if 'date_naissance' in selected_qi:
                    df_calc['annee_naissance'] = pd.to_datetime(df_calc['date_naissance']).dt.year
                    calc_qi = [c if c != 'date_naissance' else 'annee_naissance' for c in selected_qi]
                else:
                    calc_qi = selected_qi
                    
                if 'code_postal' in calc_qi:
                    df_calc['departement'] = df_calc['code_postal'].astype(str).str[:2]
                    calc_qi = [c if c != 'code_postal' else 'departement' for c in calc_qi]
                
                # Calcul
                k_series = calculate_k_anonymity(df_calc, calc_qi)
                risk_score = calculate_risk_score(k_series)
            
            # Affichage R√©sultats
            st.markdown("### R√©sultats de l'analyse")
            
            c1, c2, c3 = st.columns(3)
            c1.metric("Score de Risque Global", f"{risk_score:.0f}/100", delta=get_risk_label(risk_score), delta_color="inverse")
            c2.metric("k-anonymat Moyen", f"{k_series.mean():.1f}")
            c3.metric("Lignes √† Haut Risque (k<5)", f"{(k_series < 5).sum()}")
            
            # Graphiques
            col_chart, col_table = st.columns([2, 1])
            
            with col_chart:
                k_plot = k_series.clip(upper=50)
                fig = px.histogram(x=k_plot, nbins=50, title="Distribution du k-anonymat", 
                                 labels={'x': 'k-anonymat', 'y': 'Nb Personnes'},
                                 color_discrete_sequence=['#1E3A8A'])
                fig.add_vline(x=5, line_dash="dash", line_color="red")
                st.plotly_chart(fig, use_container_width=True)
            
            with col_table:
                st.markdown("**Combinaisons risqu√©es**")
                df_risk = df_calc.copy()
                df_risk['k'] = k_series
                st.dataframe(
                    df_risk[df_risk['k'] < 5][calc_qi + ['k']].drop_duplicates().head(15),
                    use_container_width=True, hide_index=True
                )

# --- PAGE 3: ANONYMISATION ---
elif page == "3. Anonymisation & Export":
    st.markdown('<p class="main-header">üîí Anonymisation & Export</p>', unsafe_allow_html=True)
    
    if st.session_state.df is None:
        st.info("üëà Veuillez charger des donn√©es.")
    else:
        # On utilise st.session_state.df (le complet) pour l'anonymisation, pas le filtr√©
        df_to_anonymize = st.session_state.df
        
        # Configuration des r√®gles
        st.subheader("‚öôÔ∏è Configuration des R√®gles d'Anonymisation")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            r_hash = st.checkbox("üîê Hash Identifiants", True)
            r_nom = st.checkbox("‚ùå Suppr. Noms/Pr√©noms", True)
        with col2:
            r_age = st.checkbox("üìÖ Dates ‚Üí Tranches d'√¢ge", True)
            r_geo = st.checkbox("üìç Code Postal ‚Üí D√©partement", True)
        with col3:
            r_rev = st.checkbox("üí∞ Revenus ‚Üí Tranches", True)
        
        st.markdown("---")
        
        # Bouton d'anonymisation centr√©
        col_left, col_center, col_right = st.columns([1, 2, 1])
        with col_center:
            if st.button("üöÄ Lancer l'Anonymisation", type="primary", use_container_width=True):
                # Barre de progression
                progress_bar = st.progress(0, text="Initialisation...")
                
                rules = {
                    'hash_identifiants': r_hash, 'supprimer_noms': r_nom,
                    'tranches_age': r_age, 'postal_to_dept': r_geo,
                    'supprimer_commune': True, 'tranches_revenus': r_rev
                }
                
                # Simulation d'√©tapes pour la barre de progression (car anonymize_data est rapide)
                # Dans un vrai cas, on passerait le callback √† la fonction
                progress_bar.progress(20, text="Hachage des identifiants...")
                
                df_anon, applied_rules = anonymize_data(df_to_anonymize, rules)
                
                progress_bar.progress(80, text="Application des r√®gles m√©tiers...")
                
                st.session_state.df_anon = df_anon
                st.session_state.applied_rules = applied_rules
                
                progress_bar.progress(100, text="Termin√© !")
                st.success("‚úÖ Anonymisation termin√©e avec succ√®s !")
        
        # R√©sultats
        if st.session_state.df_anon is not None:
            st.markdown("---")
            st.subheader("üìä R√©sultat de l'Anonymisation")
            
            # M√©triques de comparaison
            col1, col2, col3 = st.columns(3)
            col1.metric("Colonnes Avant", len(df_to_anonymize.columns))
            col2.metric("Colonnes Apr√®s", len(st.session_state.df_anon.columns))
            reduction = (1 - len(st.session_state.df_anon.columns)/len(df_to_anonymize.columns))*100
            col3.metric("R√©duction", f"{reduction:.0f}%", delta=f"-{reduction:.0f}%", delta_color="normal")
            
            # Aper√ßu des donn√©es
            st.dataframe(st.session_state.df_anon.head(10), use_container_width=True)
            
            # Export CSV
            st.markdown("---")
            st.subheader("üì• Export CSV")
            
            st.markdown("**Fichier anonymis√© pr√™t pour l'environnement de test**")
            
            # Export CSV
            k_final = 100 # Valeur par d√©faut simplifi√©e ou √† recalculer
            meta = create_metadata_header(st.session_state.applied_rules, k_final)
            csv_content = meta + st.session_state.df_anon.to_csv(index=False)
            
            # Encodage en utf-8-sig pour support Excel correct des accents
            csv_bytes = csv_content.encode('utf-8-sig')
            
            col1, col2, col3 = st.columns([1, 2, 1])
            with col2:
                st.download_button(
                    "‚¨áÔ∏è T√©l√©charger CSV Anonymis√©",
                    data=csv_bytes,
                    file_name=f"export_rgpd_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                    mime="text/csv",
                    type="primary",
                    use_container_width=True
                )
            
            st.info("üí° Pour le script SQL PostgreSQL √©quivalent, consultez l'onglet **4. Script SQL**")

# --- PAGE 4: SCRIPT SQL ---
elif page == "4. Script SQL":
    st.markdown('<p class="main-header">üóÑÔ∏è Script SQL PostgreSQL</p>', unsafe_allow_html=True)
    
    st.markdown("""
    **G√©n√©ration automatique de scripts d'anonymisation SQL**
    
    RetraiShield g√©n√®re automatiquement le script PostgreSQL √©quivalent pour appliquer les r√®gles d'anonymisation 
    **directement en base de donn√©es**, sans passer par des exports CSV.
    """)
    
    if st.session_state.df_anon is None:
        st.warning("‚ö†Ô∏è Veuillez d'abord anonymiser des donn√©es dans l'onglet **3. Anonymisation & Export**")
        st.info("Une fois l'anonymisation lanc√©e, le script SQL correspondant sera g√©n√©r√© automatiquement ici.")
    else:
        # G√©n√©ration du script
        sql_script = generate_sql_anonymization_script(st.session_state.applied_rules)
        
        # M√©triques sur le script
        st.markdown("---")
        st.subheader("üìä Analyse du Script G√©n√©r√©")
        
        col1, col2, col3, col4 = st.columns(4)
        
        # Comptage des lignes
        lines_count = len([l for l in sql_script.split('\n') if l.strip() and not l.strip().startswith('--')])
        col1.metric("Lignes SQL", lines_count)
        
        # Comptage des op√©rations
        operations = sql_script.count('UPDATE') + sql_script.count('ALTER TABLE') + sql_script.count('DROP COLUMN')
        col2.metric("Op√©rations DDL/DML", operations)
        
        # R√®gles appliqu√©es
        col3.metric("R√®gles Appliqu√©es", len(st.session_state.applied_rules))
        
        # Type de base
        col4.metric("SGBD Cible", "PostgreSQL", delta="Production-ready")
        
        # Affichage du script
        st.markdown("---")
        st.subheader("üìù Script G√©n√©r√©")
        
        st.code(sql_script, language="sql", line_numbers=True)
        
        # Bouton de t√©l√©chargement tr√®s visible
        st.markdown("---")
        st.subheader("üíæ T√©l√©chargement")
        
        col_left, col_center, col_right = st.columns([1, 2, 1])
        with col_center:
            st.download_button(
                "‚¨áÔ∏è T√©l√©charger le Script SQL",
                data=sql_script,
                file_name=f"anonymisation_rgpd_{datetime.now().strftime('%Y%m%d_%H%M')}.sql",
                mime="text/plain",
                type="primary",
                use_container_width=True
            )
        
        # Explications techniques
        st.markdown("---")
        st.subheader("üí° D√©tails Techniques")
        
        with st.expander("üîç Comment utiliser ce script"):
            st.markdown("""
            **Pr√©requis:**
            - PostgreSQL 12+ (pour la fonction `AGE()`)
            - Acc√®s en √©criture sur la table `assures`
            - Sauvegarde de la base avant ex√©cution
            
            **Ex√©cution:**
            ```bash
            # Via psql
            psql -U username -d database_name -f anonymisation_rgpd_YYYYMMDD_HHMM.sql
            
            # Ou via pgAdmin
            # Copier-coller le script dans l'√©diteur de requ√™tes
            ```
            
            **S√©curit√©:**
            - Le script est encapsul√© dans une transaction (`BEGIN...COMMIT`)
            - En cas d'erreur, ex√©cutez `ROLLBACK;` pour annuler les modifications
            - Testez d'abord sur un environnement de d√©veloppement
            """)
        
        with st.expander("‚öôÔ∏è Techniques SQL utilis√©es"):
            st.markdown("""
            **Fonctions PostgreSQL:**
            - `MD5()` : Hachage cryptographique des identifiants
            - `EXTRACT(YEAR FROM AGE())` : Calcul d'√¢ge pour les tranches
            - `SUBSTRING()` : Extraction des d√©partements depuis codes postaux
            - `CASE WHEN` : Logique conditionnelle pour les tranches de revenus
            
            **Op√©rations DDL:**
            - `ALTER TABLE ADD COLUMN` : Ajout de colonnes anonymis√©es
            - `ALTER TABLE DROP COLUMN` : Suppression des colonnes sensibles
            
            **Op√©rations DML:**
            - `UPDATE ... SET` : Transformation des valeurs en place
            
            **Gestion transactionnelle:**
            - `BEGIN` / `COMMIT` / `ROLLBACK` : Atomicit√© des op√©rations
            """)

